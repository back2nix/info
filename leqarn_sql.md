Конечно, вот перевод статьи "Top 25 SQL Interview Questions and Answers".

---

### Топ-25 вопросов и ответов на собеседовании по SQL.

Существуют определенные концепции SQL, с которыми вы должны быть знакомы, если планируете проходить собеседование по SQL. Независимо от того, какую СУБД вы используете, будь то MySQL, Oracle, Microsoft SQL Server, PostgreSQL или любая другая, эти концепции SQL являются общими для всех популярных СУБД.

В этом блоге вы найдете 25 теоретических вопросов по SQL, которые, я твердо уверен, охватят большинство вопросов по SQL, которые вы можете ожидать во время собеседования.

### Вопрос №1: Что такое языки DDL и DML? Приведите пример.

**DDL (Data Definition Language)** - язык определения данных. Включает в себя операторы `CREATE`, `DROP`, `ALTER` и `TRUNCATE`.

*   `CREATE`: используется для создания объектов базы данных, таких как таблицы, представления, функции и т.д.
*   `DROP`: используется для удаления объектов базы данных.
*   `ALTER`: используется для изменения структуры объектов базы данных.
*   `TRUNCATE`: используется для удаления всех данных из таблицы.

**DML (Data Manipulation Language)** - язык манипулирования данными. Включает в себя операторы `INSERT`, `UPDATE`, `DELETE` и `MERGE`.

*   `INSERT`: добавляет строки в таблицу.
*   `UPDATE`: изменяет данные в таблице.
*   `DELETE`: удаляет одну или несколько строк из таблицы.
*   `MERGE`: выполняет `INSERT` или `UPDATE` в зависимости от наличия данных.

Также существуют языки **DCL** (Data Control Language - `GRANT`, `REVOKE`), **TCL** (Transaction Control Language - `COMMIT`, `ROLLBACK`, `SAVEPOINT`) и **DQL** (Data Query Language - `SELECT`).

### Вопрос №2: В чем разница между операторами DELETE и TRUNCATE?

*   **DELETE** - это оператор DML, который может удалять строки по одной, и для него можно указать условие `WHERE`. После `DELETE` требуется `COMMIT` для сохранения изменений.
*   **TRUNCATE** - это оператор DDL, который удаляет все строки из таблицы сразу, без возможности использования `WHERE`. `COMMIT` не требуется, так как это операция DDL.


### Вопрос №2.1: В чем разница между операторами TRUNCATE и DROP?

* **TRUNCATE** - это оператор DDL, который используется для удаления всех строк из таблицы. При этом сама структура таблицы (колонки, ограничения, индексы) сохраняется. После выполнения TRUNCATE у вас остается пустая таблица, готовая для вставки новых данных. Эту операцию нельзя отменить в некоторых СУБД, и она не активирует триггеры на удаление (DELETE triggers).

* **DROP** - это также оператор DDL, но он полностью удаляет сам объект таблицы из базы данных. После выполнения команды DROP исчезают не только все данные, но и вся структура таблицы. Чтобы снова использовать эту таблицу, ее придется создавать заново с помощью оператора CREATE.

Ключевое отличие: TRUNCATE очищает таблицу от данных, а DROP удаляет саму таблицу.

### Вопрос №3: Зачем мы используем оператор CASE в SQL? Приведите пример.

Оператор `CASE` похож на оператор `IF-ELSE` в других языках программирования. Он позволяет выводить определенное значение в зависимости от условия.

Таким образом, `CASE` в `SELECT` используется для **преобразования или форматирования данных** на лету для каждой строки в результирующем наборе.

### Пример

Допустим, ваша таблица `employee` выглядит так:

| name | gender |
| :--- | :--- |
| Иван | M |
| Анна | F |
| Алекс| NULL |

Запрос:
```sql
SELECT
    name,
    CASE
        WHEN gender = 'M' THEN 'Мужской'
        WHEN gender = 'F' THEN 'Женский'
        ELSE 'Не указан'
    END AS full_gender -- AS full_gender создает заголовок для новой колонки
FROM employee;
```

**Результат выполнения запроса будет таким:**

| name | full_gender |
| :--- | :--- |
| Иван | Мужской |
| Анна | Женский |
| Алекс| Не указан |

Как видите, `CASE` просто создал новую временную колонку `full_gender` и заполнил ее значениями на основе данных из колонки `gender` для каждой строки.

### Вопрос №4: В чем разница между LEFT, RIGHT, FULL OUTER JOIN и INNER JOIN?

*   **INNER JOIN**: возвращает только те записи, которые присутствуют в обеих таблицах.
*   **LEFT JOIN**: возвращает все записи из левой таблицы и совпадающие записи из правой таблицы. Если совпадения нет, для столбцов правой таблицы возвращается NULL.
*   **RIGHT JOIN**: возвращает все записи из правой таблицы и совпадающие записи из левой таблицы. Если совпадения нет, для столбцов левой таблицы возвращается NULL.
*   **FULL OUTER JOIN**: возвращает все записи, когда есть совпадение в левой или правой таблице. По сути, это комбинация `INNER`, `LEFT` и `RIGHT JOIN`.

### Вопрос №5: В чем разница между DISTINCT и GROUP BY?

*   **DISTINCT**: используется для возврата только уникальных (различных) значений.
*   **GROUP BY**: используется для группировки строк, имеющих одинаковые значения в указанных столбцах, в итоговые строки. Часто используется с агрегатными функциями (`COUNT`, `MAX`, `MIN`, `SUM`, `AVG`).

* **Уникальное значение** в контексте `DISTINCT` означает, что из всего набора значений, даже если некоторые из них повторяются много раз, в итоговый результат будет включен только один экземпляр каждого значения.
Проще говоря, DISTINCT убирает все дубликаты.

### Вопрос №6: Каким правилам нужно следовать при использовании оператора UNION?

*   Оба запроса должны возвращать одинаковое количество столбцов.
*   Столбцы в обоих запросах должны быть в одинаковом порядке.
*   Типы данных соответствующих столбцов в обоих запросах должны быть одинаковыми.

### Вопрос №7: Что такое агрегатные функции? Назовите и объясните различные типы агрегатных функций в SQL.

Агрегатные функции выполняют вычисление на наборе значений и возвращают одно значение.
*   `SUM`: вычисляет сумму значений.
*   `AVG`: вычисляет среднее значение.
*   `MIN`: находит минимальное значение.
*   `MAX`: находит максимальное значение.
*   `COUNT`: подсчитывает количество строк.

### Вопрос №8: В чем разница между оконными функциями RANK, DENSE_RANK и ROW_NUMBER?

| Студент | Балл | **RANK()** | **DENSE_RANK()** | **ROW_NUMBER()** |
| :--- | :--- | :--- | :--- | :--- |
| Анна  | 100 | 1 | 1 | 1 |
| Борис | 95  | 2 | 2 | 2 |
| Вера  | 95  | 2 | 2 | 3 |
| Гриша | 80  | 4 | 3 | 4 |

**Основные отличия:**
- **RANK()** — пропускает ранги после дубликатов (1, 2, 2, 4)
- **DENSE_RANK()** — не пропускает ранги (1, 2, 2, 3)
- **ROW_NUMBER()** — присваивает уникальный номер каждой строке (1, 2, 3, 4)

### Вопрос №9: Можно ли использовать агрегатную функцию как оконную функцию? Если да, то как?

Да, агрегатные функции можно использовать как оконные, используя предложение `OVER()`. В отличие от обычных агрегатных функций, которые сокращают количество строк, оконные функции не изменяют количество возвращаемых строк.

### Вопрос №10: Как преобразовать текст в формат даты?

Разные СУБД имеют разные функции для этого:
*   **Oracle**: `TO_DATE('31-01-2021', 'DD-MM-YYYY')`
*   **MySQL**: `DATE_FORMAT('31-01-2021', '%d-%m-%Y')`
*   **Microsoft SQL Server**: `CAST('31-01-2021' AS DATE)`
*   **PostgreSQL**: `TO_DATE('31-01-2021', 'DD-MM-YYYY')`

### Вопрос №11: Как извлечь имя из столбца FULL_NAME, содержащего "Elon Musk"?

*   **Oracle**: `SUBSTR(full_name, 1, INSTR(full_name, ' ') - 1)`
*   **MySQL**: `SUBSTRING(full_name, 1, INSTR(full_name, ' ') - 1)`
*   **Microsoft SQL Server**: `SUBSTRING(full_name, 1, CHARINDEX(' ', full_name) - 1)`
*   **PostgreSQL**: `SUBSTR(full_name, 1, POSITION(' ' IN full_name) - 1)`

### Вопрос №12: Что такое подзапросы? Где их можно использовать?

Подзапрос — это `SELECT`-запрос, вложенный в другой `SELECT`, `INSERT`, `UPDATE` или `DELETE` запрос. Он может находиться в предложениях `SELECT`, `FROM` или `WHERE`.

### Вопрос №13: Хорошо ли иметь один и тот же подзапрос несколько раз в вашем запросе? Если нет, то как это можно решить?

Повторение одного и того же подзапроса может снизить производительность и усложнить поддержку. Этого можно избежать с помощью предложения `WITH`, которое позволяет определить подзапрос один раз и ссылаться на него несколько раз.

### Вопрос №14: Разница между предложениями WHERE и HAVING.

*   **WHERE** используется для фильтрации записей до того, как происходит какая-либо группировка.
*   **HAVING** используется для фильтрации записей после того, как они были сгруппированы с помощью `GROUP BY`.

### Вопрос №15: Что такое индексы? Зачем мы их используем?

Индекс — это объект базы данных, который создается для одного или нескольких столбцов таблицы. Он создает указатель на каждое значение в столбце, что значительно ускоряет выполнение запросов, так как базе данных не нужно сканировать всю таблицу.

### Вопрос №16: Какие шаги вы бы предприняли для настройки SQL-запроса?

1.  **Проверьте SQL-запрос**: убедитесь в правильности соединений, условий фильтрации, отсутствии декартовых произведений и повторных подзапросов.
2.  **Проверьте наличие индексов**: убедитесь, что для нужных столбцов созданы правильные индексы.
3.  **Проверьте актуальность статистики**: актуальная статистика помогает оптимизатору создать наилучший план выполнения.
4.  **Проверьте план выполнения**: план выполнения показывает, как база данных будет выполнять запрос, и может указать на узкие места.

### Вопрос №17: В чем разница между первичным ключом, уникальным ключом и внешним ключом?

*   **Первичный ключ**: столбец (или столбцы), который однозначно идентифицирует каждую запись в таблице. Не может содержать `NULL` и должен иметь только уникальные значения.
*   **Уникальный ключ**: также обеспечивает уникальность значений в столбце, но может содержать одно `NULL` значение.
*   **Внешний ключ**: используется для создания связи между двумя таблицами.

### Вопрос №18: В чем разница между представлением (view) и синонимом (synonym)?

*   **Представление (View)**: это сохраненный `SELECT`-запрос, который можно использовать как виртуальную таблицу.
*   **Синоним (Synonym)**: это альтернативное имя для объекта базы данных, такого как таблица, представление или хранимая процедура.

### Вопрос №19: Когда функцию НЕЛЬЗЯ вызывать из SELECT-запроса?

Если функция выполняет операции DML (`INSERT`, `UPDATE`, `DELETE`), ее нельзя вызывать из `SELECT`-запроса, так как `SELECT` не может изменять состояние базы данных.

### Вопрос №20: Что такое триггер?

Триггер — это хранимая процедура, которая автоматически выполняется при возникновении определенного события (например, `INSERT`, `UPDATE` или `DELETE`) в таблице.

### Вопрос №21: В чем разница между представлениями (views) и материализованными представлениями (materialized views)?

*   **Представления**: выполняют запрос каждый раз, когда к ним обращаются, и всегда показывают актуальные данные.
*   **Материализованные представления**: хранят результат запроса как физическую таблицу и периодически обновляются. Это может улучшить производительность, особенно для сложных запросов.

### Вопрос №22: Что такое оператор MERGE?

Оператор `MERGE` выполняет `INSERT`, `UPDATE` или `DELETE` для целевой таблицы на основе результатов соединения с исходной таблицей.

### Вопрос №23: Какую функцию можно использовать для получения вчерашней даты?

*   **Oracle**: `SYSDATE - 1`
*   **MySQL**: `DATE_SUB(SYSDATE(), INTERVAL 1 DAY)`
*   **Microsoft SQL Server**: `DATEADD(DAY, -1, GETDATE())`
*   **PostgreSQL**: `CURRENT_DATE - 1`

### Вопрос №24: В чем разница между функцией и процедурой?

*   **Функция** всегда должна возвращать значение. Ее можно вызывать из `SELECT`-запроса.
*   **Процедура** не обязана возвращать значение. Ее нельзя вызывать из `SELECT`-запроса.

### Вопрос №25: Что такое PRAGMA AUTONOMOUS_TRANSACTION?

`PRAGMA AUTONOMOUS_TRANSACTION` позволяет хранимой программе (например, процедуре) выполнять транзакции, которые не зависят от основной транзакции. `COMMIT` или `ROLLBACK` в такой процедуре не повлияют на основную транзакцию.
